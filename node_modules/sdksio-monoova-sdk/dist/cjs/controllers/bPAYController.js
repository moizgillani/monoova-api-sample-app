"use strict";
/**
 * Monoova Payments APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */
exports.__esModule = true;
exports.BPAYController = void 0;
var tslib_1 = require("tslib");
var core_1 = require("@apimatic/core");
var dTOBPAYBillerResponseV1_1 = require("../models/dTOBPAYBillerResponseV1");
var dTOBPAYBillersResponseV1_1 = require("../models/dTOBPAYBillersResponseV1");
var dTOBPAYHistoryResponseV1_1 = require("../models/dTOBPAYHistoryResponseV1");
var dTOBPAYReceiptResponseV1_1 = require("../models/dTOBPAYReceiptResponseV1");
var dTOValidateBPAYResponseV1_1 = require("../models/dTOValidateBPAYResponseV1");
var schema_1 = require("../schema");
var baseController_1 = require("./baseController");
var BPAYController = /** @class */ (function (_super) {
    tslib_1.__extends(BPAYController, _super);
    function BPAYController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns a report of all received  BPAY transactions for the day with associated details. If
     * requested multiple times on the current date (calendar day, AEDT), the report is cumulative. E.g. if,
     * on the same day, a report is requested at 10am and another one at 1pm, the report at 1pm will
     * contain all the transactions already contained in the 10am report, in addition to any new
     * transactions. <br/> <br/> The report is an application/octet-stream, columns are comma separated.
     * Where a comma(,) or double quote(") is present in any of the below fields, the field will be encased
     * in double quotes and/or escaped as per <a href="https://tools.ietf.org/html/rfc4180"
     * target="_blank">RFC4180</a><br> Columns are as follows:&nbsp; <style type="text/css"> .tb { table-
     * layout:auto; width:100px;!important } .td { overflow:hidden; white-space:nowrap; text-overflow:
     * ellipsis; !important} </style> <table class="tb"> <tr> <td class="td"> Transaction Id </td> <td
     * class="td"> Batch Id </td> <td class="td"> BPAY Settlement Date </td> <td class="td"> Payment
     * Accepted DateTime </td> <td class="td"> Payment Type </td> <td class="td"> Payer Institution Code
     * </td> <td class="td"> Payer State </td> <td class="td"> Biller Code </td> <td class="td"> Customer
     * Reference Number </td> <td class="td"> Payment Method </td> <td class="td"> Amount </td> <td
     * class="td"> Transaction Reference Number </td> </tr> <tr> <td class="td"> <br/> <br/> Monoova
     * generated Unique ID.<br/> Integer.<br/> <br/> <br/> <br/> </td> <td class="td"> Payment Batch ID.
     * <br/> Payments come in batches <br/> throughout the day. <br/> Integer.<br/> </td> <td class="td">
     * AEDT, Sydney. <br/> Max 27 chars. </td> <td class="td"> AEDT, Sydney. <br/> Max 27 chars. </td> <td
     * class="td"> Possible values:&nbsp; <br/> 'Payment', 'Error Correction', 'Reversal'. </td> <td
     * class="td"> PayerInstitutionCode. <br/> Max 3 chars. </td> <td class="td"> PayerState <br/> Max 3
     * chars. </td> <td class="td"> BillerCode <br/> Max 10 chars. </td> <td class="td">
     * CustomerReferenceNumber  <br/> Max 20 chars. </td> <td class="td"> PaymentMethod <br/> Max 3 chars.
     * <br/> </td> <td class="td"> Amount, <br/> 2 decimal places <br/> for cents. Max 12 chars. </td> <td
     * class="td"> TransactionReferenceNumber. <br/> Max 21 chars. </td> </tr> </table>
     *
     * @param date Format:&nbsp; 'yyyy-MM-dd'. The date for which Monoova received the BPAY Receivable
     *                       transactions.
     * @param skip Number of records to skip. 1 is the first record.
     * @param take Number of records to take.
     * @return Response from the API call
     */
    BPAYController.prototype.bPAYReceivablesReport = function (date, skip, take, requestOptions) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var req, mapped;
            return tslib_1.__generator(this, function (_a) {
                req = this.createRequest('GET');
                mapped = req.prepareArgs({
                    date: [date, (0, schema_1.string)()],
                    skip: [skip, (0, schema_1.optional)((0, schema_1.number)())],
                    take: [take, (0, schema_1.optional)((0, schema_1.number)())]
                });
                req.query('skip', mapped.skip);
                req.query('take', mapped.take);
                req.appendTemplatePath(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject(["/bpay/v1/bpayInReport/", ""], ["/bpay/v1/bpayInReport/", ""])), mapped.date);
                req.throwOn(400, core_1.ApiError, 'Bad request');
                req.throwOn(500, core_1.ApiError, 'Internal Server Error');
                return [2 /*return*/, req.callAsJson((0, schema_1.unknown)(), requestOptions)];
            });
        });
    };
    /**
     * This API validates the BPAY Biller Code and optionally the BPAY Customer Reference Number and Amount.
     * For a complete BPAY validation the BPAY Biller Code, BPAY Customer Reference Number and Amount must
     * be supplied. When fully validated a BPAY financial transaction should be made as soon as practicable
     * as some BPAY combinations are date sensitive. BPAY validation uses the BPAY subsystem error codes.
     * <br/> Sample URL:&nbsp; https://api.mpay.com.au/bpay/v1/validate/{billerCode}?
     * custRef={CRN}&amount={amount}
     *
     * @param billerCode This is the BPAY biller code that was requested. billerCode must be numeric
     * @param custRef    BPAY Customer Reference Number. If this field is empty this denotes that the
     *                             customerReferenceNumber is variable for each bill and should not be reused.
     * @param amount     Bill amount to be validated. <strong> Note if CustRef is not provided, amount will
     *                             not validate as it is dependent on both the CRN and Biller. </strong> The maximum
     *                             value of the field is $9999999999.99.
     * @return Response from the API call
     */
    BPAYController.prototype.bPAYValidate = function (billerCode, custRef, amount, requestOptions) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var req, mapped;
            return tslib_1.__generator(this, function (_a) {
                req = this.createRequest('GET');
                mapped = req.prepareArgs({
                    billerCode: [billerCode, (0, schema_1.string)()],
                    custRef: [custRef, (0, schema_1.optional)((0, schema_1.string)())],
                    amount: [amount, (0, schema_1.optional)((0, schema_1.number)())]
                });
                req.query('custRef', mapped.custRef);
                req.query('amount', mapped.amount);
                req.appendTemplatePath(templateObject_2 || (templateObject_2 = tslib_1.__makeTemplateObject(["/bpay/v1/validate/", ""], ["/bpay/v1/validate/", ""])), mapped.billerCode);
                req.throwOn(400, core_1.ApiError, 'Bad request');
                req.throwOn(500, core_1.ApiError, 'Internal Server Error');
                return [2 /*return*/, req.callAsJson(dTOValidateBPAYResponseV1_1.dTOValidateBPAYResponseV1Schema, requestOptions)];
            });
        });
    };
    /**
     * This API returns extended information for the BPAY biller. Status will be “UnknownBillerCode” if
     * Biller Code is invalid.
     *
     * @param billerCode This is the BPAY biller code that was requested. billerCode must be numeric
     * @return Response from the API call
     */
    BPAYController.prototype.bPAYGetBiller = function (billerCode, requestOptions) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var req, mapped;
            return tslib_1.__generator(this, function (_a) {
                req = this.createRequest('GET');
                mapped = req.prepareArgs({ billerCode: [billerCode, (0, schema_1.string)()] });
                req.appendTemplatePath(templateObject_3 || (templateObject_3 = tslib_1.__makeTemplateObject(["/bpay/v1/biller/", ""], ["/bpay/v1/biller/", ""])), mapped.billerCode);
                req.throwOn(400, core_1.ApiError, 'Bad request');
                req.throwOn(500, core_1.ApiError, 'Internal Server Error');
                return [2 /*return*/, req.callAsJson(dTOBPAYBillerResponseV1_1.dTOBPAYBillerResponseV1Schema, requestOptions)];
            });
        });
    };
    /**
     * This API returns the list of BPAY receipts. <br/> <strong> Note&#58;</strong>  Filters - One of the
     * below options should be provided by customer. <br/> 1) UniqueReference <br/> 2) Biller Code +
     * CustomerReferenceNumber + DateTime
     *
     * @return Response from the API call
     */
    BPAYController.prototype.bPAYGetReceipts = function (requestOptions) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var req;
            return tslib_1.__generator(this, function (_a) {
                req = this.createRequest('GET', '/bpay/v1/receipts');
                req.throwOn(400, core_1.ApiError, 'Bad request');
                req.throwOn(500, core_1.ApiError, 'Internal Server Error');
                return [2 /*return*/, req.callAsJson(dTOBPAYReceiptResponseV1_1.dTOBPAYReceiptResponseV1Schema, requestOptions)];
            });
        });
    };
    /**
     * This API returns an array of BPAY billers matched to the case insensitive search string. The system
     * matches on the billerLongName and billerShortName. Use skip and take to page through result set.
     * Skip and take will be changed back to their defaults if they are over-range. Status will be
     * “UnknownBillerCode” if there are no matches.
     *
     * @param search The search string
     * @param skip   The actual number of records skipped.
     * @param take   The number of records that were requested.
     * @return Response from the API call
     */
    BPAYController.prototype.bPAYGetBillers = function (search, skip, take, requestOptions) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var req, mapped;
            return tslib_1.__generator(this, function (_a) {
                req = this.createRequest('GET', '/bpay/v1/billers');
                mapped = req.prepareArgs({
                    search: [search, (0, schema_1.optional)((0, schema_1.string)())],
                    skip: [skip, (0, schema_1.optional)((0, schema_1.number)())],
                    take: [take, (0, schema_1.optional)((0, schema_1.number)())]
                });
                req.query('search', mapped.search);
                req.query('skip', mapped.skip);
                req.query('take', mapped.take);
                req.throwOn(400, core_1.ApiError, 'Bad request');
                req.throwOn(500, core_1.ApiError, 'Internal Server Error');
                return [2 /*return*/, req.callAsJson(dTOBPAYBillersResponseV1_1.dTOBPAYBillersResponseV1Schema, requestOptions)];
            });
        });
    };
    /**
     * This API returns the mWallets history of BPAY payments. The returned history list is sorted by the
     * count property of the BPAYHistoryItem descending.
     *
     * @param accountNumber associated 'mWallet' 16 digit number
     * @param take          The number of records that were requested.
     * @return Response from the API call
     */
    BPAYController.prototype.bPAYGetHistory = function (accountNumber, take, requestOptions) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var req, mapped;
            return tslib_1.__generator(this, function (_a) {
                req = this.createRequest('GET');
                mapped = req.prepareArgs({
                    accountNumber: [accountNumber, (0, schema_1.bigint)()],
                    take: [take, (0, schema_1.optional)((0, schema_1.number)())]
                });
                req.query('take', mapped.take);
                req.appendTemplatePath(templateObject_4 || (templateObject_4 = tslib_1.__makeTemplateObject(["/bpay/v1/history/", ""], ["/bpay/v1/history/", ""])), mapped.accountNumber);
                req.throwOn(400, core_1.ApiError, 'Bad request');
                req.throwOn(500, core_1.ApiError, 'Internal Server Error');
                return [2 /*return*/, req.callAsJson(dTOBPAYHistoryResponseV1_1.dTOBPAYHistoryResponseV1Schema, requestOptions)];
            });
        });
    };
    return BPAYController;
}(baseController_1.BaseController));
exports.BPAYController = BPAYController;
var templateObject_1, templateObject_2, templateObject_3, templateObject_4;
//# sourceMappingURL=bPAYController.js.map